Add a helper to persist phase-gap data
Create a new file in your repository at analysis/phase_persist.py with the following content:

python
Copy
# analysis/phase_persist.py
from pathlib import Path
import json
from datetime import datetime, timezone

ART = Path("artifacts")
ART.mkdir(exist_ok=True)

def append_phase_gap(deg_value: float, ts_utc=None):
    """
    Store a timestamped record of the current phase gap in degrees.
    It appends to artifacts/phase_gap_history.json (keeping the last 5,000 points).
    """
    if ts_utc is None:
        ts_utc = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
    rec = {"as_of_utc": ts_utc, "phase_deg": float(deg_value)}
    p = ART / "phase_gap_history.json"
    data = {"history": []}
    if p.exists():
        try:
            data = json.loads(p.read_text())
            if not isinstance(data, dict) or "history" not in data:
                data = {"history": []}
        except Exception:
            data = {"history": []}
    data["history"].append(rec)
    # keep only the last 5,000 records
    data["history"] = data["history"][-5000:]
    p.write_text(json.dumps(data, ensure_ascii=False))
Call append_phase_gap(phase_gap_degrees) whenever you compute your phase gap; this writes the data needed by the ETA endpoint.

2. Add /api/eta to your Flask routes
In your main routes.py (or a new routes_eta.py registered with the app), add this code:

python
Copy
# Add these imports near the top of routes.py
from pathlib import Path
import json
from datetime import datetime, timezone, timedelta
import numpy as np
from flask import jsonify

# Helper: load history from artifacts file
def _load_phase_history():
    p = Path("artifacts/phase_gap_history.json")
    if not p.exists():
        return []
    try:
        obj = json.loads(p.read_text())
        H = obj.get("history", [])
        out = []
        for h in H:
            ts = h.get("as_of_utc")
            val = h.get("phase_deg")
            if ts is None or val is None:
                continue
            try:
                t = datetime.fromisoformat(ts.replace("Z","+00:00"))
            except Exception:
                continue
            out.append((t, float(val)))
        out.sort(key=lambda x: x[0])
        return out
    except Exception:
        return []

# Helper: unwrap degrees to radians
def _unwrap_deg_to_rad(deg_series):
    rad = np.deg2rad(np.array(deg_series, dtype=float))
    return np.unwrap(rad)

# Fit a line to the last few months of data and derive ETA
def _robust_fit_eta(t_list, phase_rad, min_days=150, max_days=300):
    """
    Fit a robust linear slope to the last [min_days, max_days] days.
    Returns a dict with eta_days if the phase slope is negative.
    """
    if len(t_list) < 20:
        return None
    # Select a window of at most max_days
    t_end = t_list[-1]
    t_start = t_end - timedelta(days=max_days)
    idx = [i for i, t in enumerate(t_list) if t >= t_start]
    if len(idx) < 20:
        idx = list(range(max(0, len(t_list)-200), len(t_list)))
    # Map times to days since window start
    t_sel = [t_list[i] for i in idx]
    y = phase_rad[idx]
    t0 = t_sel[0]
    x = np.array([(t - t0).total_seconds() / 86400.0 for t in t_sel], dtype=float)
    # Trim outliers using a simple iterative approach
    for _ in range(2):
        coeffs = np.polyfit(x, y, 1)
        m, b = coeffs[0], coeffs[1]
        yhat = m * x + b
        resid = y - yhat
        q1, q3 = np.percentile(resid, [5, 95])
        keep = (resid >= q1) & (resid <= q3)
        x, y = x[keep], y[keep]
        if len(x) < 10:
            break
    m, b = np.polyfit(x, y, 1)
    phi_now = float(y[-1])
    if m >= 0:
        return None  # no convergence if slope non-negative
    eta_days = abs(phi_now) / (-m)
    return {"eta_days": float(eta_days)}

# Add a new route in routes.py:
@app.route("/api/eta", methods=["GET"])
def api_eta():
    """
    Use the saved phase-gap history to compute the convergence ETA.
    If the phase gap slope is not closing, return a message instead.
    """
    H = _load_phase_history()
    if not H:
        return jsonify({"ok": False, "error": "No phase history available"}), 200
    t_list = [h[0] for h in H]
    deg_list = [h[1] for h in H]
    phase_rad = _unwrap_deg_to_rad(deg_list)
    result = _robust_fit_eta(t_list, phase_rad)
    asof = datetime.now(timezone.utc)
    if not result:
        return jsonify({
            "ok": True,
            "as_of_utc": asof.isoformat().replace("+00:00", "Z"),
            "message": "No convergence (phase slope is non-negative or insufficient data)"
        }), 200
    eta_days = result["eta_days"]
    eta_date = (asof + timedelta(days=eta_days)).date().isoformat()
    return jsonify({
        "ok": True,
        "as_of_utc": asof.isoformat().replace("+00:00", "Z"),
        "eta_days": eta_days,
        "eta_date_utc": eta_date
    }), 200
Make sure to import numpy and register this route with your Flask app.

3. Use the helper in your existing pipeline
Wherever you compute phase_deg for your dashboard (probably in the GTI or timing pipeline), call:

python
Copy
from analysis.phase_persist import append_phase_gap
# Suppose phase_deg is computed:
append_phase_gap(phase_deg)
This writes the phase gap into artifacts/phase_gap_history.json, so the /api/eta endpoint has data to read.

4. Commit and deploy
Add the new file and modify routes.py in your repository:

bash
Copy
git add analysis/phase_persist.py routes.py
git commit -m "Add phase gap persistence and /api/eta endpoint"
git push origin main